# 项目亮点

1、用户登录：使用Redis实现分布式Session,解决集群间登录态同步问题；并使用Hash代替String来存储
用户信息，节约了x%的内存并便于单字段的修改。

2.对于项目中复杂的集合处理（比如为队伍列表关联已加入队伍的用户），使用Java8 Stream API和
Lambda表达式来简化编码。
3.使用Easy Excel读取收集来的基础用户信息，并通过自定义线程池+CompletableFuture并发编程提高批
量导入数据库的性能。实测导入100万行的时间从x秒缩短至x秒。一（需要自己实际测试对比数据）
导航知识
4.使用Redis缓存首页高频访问的用户信息列表，将接口响应时长从x秒缩短至xx秒。且通过自定义Redis
序列化器来解决数据乱码、空间浪费的问题。
5.为解决首次访问系统的用户主页加载过慢的问题，使用Spring Scheduler定时任务来实现缓存预热，并通过
分布式锁保证多机部署时定时任务不会重复执行。
6.为解决同一用户重复加入队伍、入队人数超限的问题，使用Redision分布式锁来实现操作互斥，保证了接口
幂等性。
7.使用编辑距离算法实现了根据标签匹配最相似用户的功能，并通过优先队列来减少TOP N运算过程中的内存
占用。
8.自主编写Dockerfile,并通过第三方容器托管平台实现自动化镜像构建及容器部署，提高部署上线效率。
9.使用Knife4j+Swagger自动生成后端接口文档，并通过编写ApiOperation等注解补充接口注释，避免了
人工编写维护文档的麻烦。

模拟大批量的用户

向数据库中插入100万条用户数据，采用for循环直接像数据库中插入100万条数据实测花费290秒
用mybatis中的批量插入耗时86秒 用线程池异步执行耗时26秒性能大幅提高

# 缓存预热
定时任务实现
1、Spring Scheduler（springboot默认整合了）
2、Quartz（独立于Spring存在的定时任务框架）
3、XXL-Job之类的分布式任务调度平台（界面+sdk）

第一种方式： /job/PreCacheJob.java
1、主类总是能够开启@EnableScheduling
2、给要执行的方法开启Scheduled注解

# 分布式锁
如果我们的后端数据存储在100个不同的服务器上，如果100台服务器都执行定时任务会浪费资源
也会造成脏数据，比如重复插入

解决办法：
1、分离定时任务程序和主程序，只在一个服务器上运行定时任务。成本太大
2、写死配置，每个服务器都执行定时任务，但是只有ip符合配置的服务器才真实执行业务逻辑。成本最低
    但是我们的ip可能是不固定的，把ip写的太死
```java
/***
if(ip!="10.0.0.1")
    return;
**/
```
3、推荐：动态配置，配置是可以轻松的、很方便地更新（代码无需重启），但是只有ip符合配置的服务器才会执行逻辑
  *数据库
  *redis
  *配置中心（Nacos、Apollo、SpringCloud Config）
  问题：服务器多了、ip不可控还是很麻烦，还需要人工修改
